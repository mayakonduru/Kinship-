import argparse
import json
import relationships
import sys

class Person:
    """ 
    Represents the relationship between someone and their relatives on a family 
    tree.
    
    Attributes:
        name(str): The name of the individual
        gender(str): The gender of the individual
        parents(list): A list of parents
        spouse(Person): The spouse of a person based on the Person object

    """
    def __init__(self, name, gender):
        """
        Represents the relationship between someone and their relatives on a family 
                tree.
    
        Args:
            name(str): The name of the individual
            gender(str): The gender of the individual
            parents(list): A list of parents
            spouse(Person): The spouse of a person based on the Person object
        Side effects:
            Modifys the attributes of the object.
        """
        self.name = name
        self.gender = gender
        self.parents = []
        self.spouse = None
    
    def add_parent(self, parent):
        """
        Adds parent to the list of parents
        
        Attributes:
            parents(list): A list of parents
        """
        self.parents.append(parent)
        
    def set_spouse(self, spouse):
        """
        Shows the spouse of the individual if they have one
        
        Attributes:
            spouse(Person): The spouse of a person based on the Person object
        """
        self.spouse = spouse
   
    def connections(self):
        """
        Calculates all of the possible and existing connections between people.
        
        Returns:
            dict: A dictionary of the person and who they are related to.
            
        Side effect: 
            Pops an element and raises a KeyError
        """
        cdict = {self: ""}
        queue = [self]
        
        while queue:
            person = queue.pop(0)
            personpath = cdict[person]
            
            for parent in person.parents:
                if parent not in cdict:
                    cdict[parent] = personpath + "P"
                    queue.append(parent)

            if "S" not in personpath and person.spouse and person.spouse not in cdict:
                cdict[person.spouse] = personpath + "S"
                queue.append(person.spouse)
                
        return cdict
            
    def relation_to(self, other):
        """
        Determines the relationship between two different people.
        
        Args:
            other(Person): The other person who one is related to.
            relationships (dict): Maps the connection paths
            
        Returns:
            str: The relationship description, whether they are a close or 
                 distant relative
        """
        self_connections = self.connections()
        other_connection = other.connections()
        
        common_relatives=set(self_connections.keys()) & set(other_connection.keys())
        
        if not common_relatives:
            return None
        
        combined_paths = (f"{self_connections[key]}:{other_connection[key]}"
                          for key in common_relatives)
        lcr = min(combined_paths, key=len)
         
        if lcr in relationships.relationships:
            return relationships.relationships[lcr][self.gender]
        
        return "distant relative"
class Family:
    """
    Represents a family and their relationships.
    Attributes:
        people(dict): Maps the names to the people.
    """
    def __init__(self, familydata):
        """
        Initializes a family tree from the read file
        Args:
            familydata(dict): Dictionary that contains the individuals, 
                              couples, and parents.
        Side effects:
            Modifies sets by adding elements from an iterable. 
        """
        self.people = {}
        for name, gender in familydata["individuals"].items():
            self.people[name] = Person(name, gender)
        
        for name, parents in familydata["parents"].items():
            person = self.people[name]
            for parent_name in parents:
                person.add_parent(self.people[parent_name])
                
        for couple in familydata["couples"]:
            name1, name2 = self.people[couple[0]], self.people[couple[1]]
            name1.set_spouse(name2)
            name2.set_spouse(name1)
 
            
    def relation(self, name1, name2):
        """
        Determines the relationship between two individuals on the family tree.
        
        Args:
            name1(str): The name of the first person.
            name2(str): The name of the second person.
        Returns:
            str: The relationship description.
        """
        person1 = self.people[name1]
        person2 = self.people[name2]
        return person1.relation_to(person2)

         
def main(json_file_path, name1, name2):
    """
    Reads the JSON file and outputs the family tree
    
    Args:
        json_file_path (str): Path to the JSON file.
        name1 (str): The first person's name.
        name2 (str): The second person's name.
    Side effects:
        Outputs to the console.
    """
    with open(json_file_path, 'r', encoding = "utf-8") as file:
        familydata = json.load(file)
        
    family = Family(familydata)
    relationship = family.relation(name1, name2)
    
    if relationship is None:
        print(f"{name1} is not related to {name2}")
    else:
        print(f"{name1} is {name2}'s {relationship}")
        

def parse_args(args):
    """
    Parses command-line arguments.
    Args:
        args(list): List of command line arguments
    Returns:
        Namespace: Parsed command-line arguments
    """
    parser = argparse.ArgumentParser(description="Defines the relationship between"
                                     "two people.")
    parser.add_argument("filepath", help="Path to read the file given")
    parser.add_argument("name1", help = "First person's name")
    parser.add_argument("name2", help="Second person's name")
    return parser.parse_args(args)
    
if __name__ == "__main__":
    arguments = parse_args(sys.argv[1:])
    main(arguments.filepath, arguments.name1, arguments.name2)
    
        
